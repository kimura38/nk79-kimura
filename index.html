<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>ブロック崩し</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
html,body{
 margin:0;
 width:100%;
 height:100%;
 background:#111;
 overflow:hidden;
 font-family:sans-serif;
}
canvas{
 display:block;
 background:#222;
 touch-action:none;
}
#starBtn{
 position:absolute;
 top:10px;
 right:10px;
 width:50px; height:50px;
 background:gold;
 border-radius:50%;
 font-size:24px;
 border:none;
 cursor:pointer;
 z-index:10;
}
</style>
</head>
<body>

<button id="starBtn">⭐︎</button>
<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const starBtn = document.getElementById("starBtn");

// ===== 基本設定 =====
const GRID = 8;
let W,H,SIZE,OFFSET_Y,SLOT_Y;
const SLOT_SCALE = 0.7;

let board, pieces, dragging=null;
let score = 0;
let combo = 0;
let bugMode = false;

// ===== ブロック形 =====
const SHAPES = [
 [[1]],
 [[1,1]],
 [[1],[1]],
 [[1,1,1]],
 [[1],[1],[1]],
 [[1,1],[1,1]],
 [[1,1,1],[0,1,0]]
];

// ===== 画面サイズ =====
function resize(){
 W = Math.min(innerWidth, 480);
 H = innerHeight;
 canvas.width = W;
 canvas.height = H;

 SIZE = Math.floor(W / (GRID + 1));
 OFFSET_Y = SIZE * 1.5;
 SLOT_Y = OFFSET_Y + GRID * SIZE + SIZE*0.6;
}
window.addEventListener("resize", resize);
resize();

// ===== 初期化 =====
function reset(){
 board = Array.from({length:GRID},()=>Array(GRID).fill(0));
 score = 0;
 combo = 0;
 newPieces();
}
reset();

// ===== 新ブロック =====
function newPieces(){
 pieces=[];
 for(let i=0;i<3;i++){
  pieces.push({
   shape: SHAPES[Math.floor(Math.random()*SHAPES.length)],
   x: W/2 + (i-1)*SIZE*3,
   y: SLOT_Y
  });
 }
}

// ===== 描画 =====
function drawCell(x,y,s,color){
 ctx.fillStyle=color;
 ctx.fillRect(x,y,s,s);
 ctx.strokeStyle="#333";
 ctx.strokeRect(x,y,s,s);
}

// ===== 判定 =====
function canPlace(px,py,shape){
 for(let y=0;y<shape.length;y++){
  for(let x=0;x<shape[y].length;x++){
   if(shape[y][x]){
    let gx = Math.floor((px+x*SIZE)/SIZE);
    let gy = Math.floor((py+y*SIZE-OFFSET_Y)/SIZE);
    if(gx<0||gx>=GRID||gy<0||gy>=GRID||board[gy][gx]) return false;
   }
  }
 }
 return true;
}

function place(px,py,shape){
 shape.forEach((r,y)=>r.forEach((v,x)=>{
  if(v){
   let gx=Math.floor((px+x*SIZE)/SIZE);
   let gy=Math.floor((py+y*SIZE-OFFSET_Y)/SIZE);
   board[gy][gx]=1;
  }
 }));
}

// ===== ライン消去＋コンボ =====
function clearLines(){
 let cleared = 0;

 for(let y=0;y<GRID;y++){
  if(board[y].every(v=>v)){
   board[y].fill(0);
   cleared++;
  }
 }

 for(let x=0;x<GRID;x++){
  let full=true;
  for(let y=0;y<GRID;y++) if(!board[y][x]) full=false;
  if(full){
   for(let y=0;y<GRID;y++) board[y][x]=0;
   cleared++;
  }
 }

 if(cleared > 0){
  combo++;
  const base = cleared * 100;
  const bonus = Math.round(base * (combo>1 ? 1.45 : 1));
  score += bonus;
 }else{
  combo = 0;
 }
}

// ===== ゴースト位置 =====
function ghostPos(p){
 return {
  x: Math.round(p.x / SIZE) * SIZE,
  y: Math.round((p.y-OFFSET_Y)/SIZE)*SIZE + OFFSET_Y
 };
}

// ===== 描画全体 =====
function draw(){
 ctx.clearRect(0,0,W,H);

 // バグモード時は全部ランダム
 if(bugMode){
  for(let y=0;y<GRID;y++){
   for(let x=0;x<GRID;x++){
    if(board[y][x]){
     drawCell(x*SIZE + Math.random()*20-10,
              OFFSET_Y+y*SIZE + Math.random()*20-10,
              SIZE,
              '#'+Math.floor(Math.random()*16777215).toString(16));
    }
   }
  }
  pieces.forEach(p=>{
   p.shape.forEach((r,y)=>r.forEach((v,x)=>{
    if(v){
     drawCell(p.x + x*SIZE + Math.random()*20-10,
              p.y + y*SIZE + Math.random()*20-10,
              SIZE, '#'+Math.floor(Math.random()*16777215).toString(16));
    }
   }));
  });
  ctx.fillStyle='white';
  ctx.font='30px sans-serif';
  ctx.fillText("バグモード発動中！",10,50);
  return;
}

// タイトル
 ctx.fillStyle="white";
 ctx.font=`bold ${SIZE*0.7}px sans-serif`;
 ctx.fillText("ブロック崩し", 10, SIZE);

// 点線グリッド
 ctx.setLineDash([5,5]);
 ctx.strokeStyle="#444";
 for(let i=0;i<=GRID;i++){
  ctx.beginPath();
  ctx.moveTo(i*SIZE, OFFSET_Y);
  ctx.lineTo(i*SIZE, OFFSET_Y+GRID*SIZE);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(0, OFFSET_Y+i*SIZE);
  ctx.lineTo(GRID*SIZE, OFFSET_Y+i*SIZE);
  ctx.stroke();
 }
 ctx.setLineDash([]);

// 固定ブロック
 for(let y=0;y<GRID;y++){
  for(let x=0;x<GRID;x++){
   if(board[y][x]) drawCell(x*SIZE, OFFSET_Y+y*SIZE, SIZE, "#4caf50");
  }
 }

// ゴースト
 if(dragging){
  const g = ghostPos(dragging.p);
  if(canPlace(g.x,g.y,dragging.p.shape)){
   ctx.globalAlpha=0.4;
   dragging.p.shape.forEach((r,y)=>r.forEach((v,x)=>{
    if(v) drawCell(g.x+x*SIZE, g.y+y*SIZE, SIZE, "#aaa");
   }));
   ctx.globalAlpha=1;
  }
 }

// 手持ちブロック
 pieces.forEach(p=>{
  const s = (p.y>=SLOT_Y)? SIZE*SLOT_SCALE : SIZE;
  p.shape.forEach((r,y)=>r.forEach((v,x)=>{
   if(v) drawCell(p.x+x*s, p.y+y*s, s, "#fbc02d");
  }));
 });

// スコア
 ctx.fillStyle="white";
 ctx.font=`${SIZE*0.5}px sans-serif`;
 ctx.fillText("SCORE: "+score, 10, OFFSET_Y+GRID*SIZE+SIZE*0.7);

// コンボ
 if(combo>1){
  ctx.fillText("COMBO x"+combo, 10, OFFSET_Y+GRID*SIZE+SIZE*1.3);
 }
}

// ===== 入力 =====
canvas.addEventListener("pointerdown",e=>{
 const r=canvas.getBoundingClientRect();
 const mx=e.clientX-r.left, my=e.clientY-r.top;
 pieces.forEach(p=>{
  const s=(p.y>=SLOT_Y)?SIZE*SLOT_SCALE:SIZE;
  const w=p.shape[0].length*s, h=p.shape.length*s;
  if(mx>p.x&&mx<p.x+w&&my>p.y&&my<p.y+h){
   dragging={p,ox:mx-p.x,oy:my-p.y};
  }
 });
});

canvas.addEventListener("pointermove",e=>{
 if(!dragging) return;
 const r=canvas.getBoundingClientRect();
 dragging.p.x=e.clientX-r.left-dragging.ox;
 dragging.p.y=e.clientY-r.top-dragging.oy;
});

canvas.addEventListener("pointerup",()=>{
 if(!dragging) return;
 const p=dragging.p;
 const g=ghostPos(p);

 if(canPlace(g.x,g.y,p.shape)){
  place(g.x,g.y,p.shape);
  pieces=pieces.filter(x=>x!==p);
  clearLines();
  if(pieces.length===0) newPieces();
 }else{
  p.y=SLOT_Y;
 }

 dragging=null;
});

// ===== ⭐︎ボタン =====
starBtn.addEventListener("click",()=>{
 const code = prompt("ボーナスコードを入力");
 if(code === "11451419194545810"){
  bugMode = true;
  alert("バグモード発動！");
 }
});

// ===== ループ =====
function loop(){
 draw();
 requestAnimationFrame(loop);
}
loop();
</script>

</body>
</html>
