<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Tetris</title>
<style>
body{
 margin:0;
 background:black;
 display:flex;
 justify-content:center;
 align-items:center;
 height:100vh;
}
canvas{
 background:#111;
}
</style>
</head>
<body>

<canvas id="game" width="300" height="600"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const COLS = 10;
const ROWS = 20;
const SIZE = 30;

let board = Array.from({length:ROWS},()=>Array(COLS).fill(0));

const COLORS = [
 null,
 "#00f0f0", // I
 "#0000f0", // J
 "#f0a000", // L
 "#f0f000", // O
 "#00f000", // S
 "#a000f0", // T
 "#f00000"  // Z
];

const SHAPES = [
 [],
 [[1,1,1,1]],
 [[2,0,0],[2,2,2]],
 [[0,0,3],[3,3,3]],
 [[4,4],[4,4]],
 [[0,5,5],[5,5,0]],
 [[0,6,0],[6,6,6]],
 [[7,7,0],[0,7,7]]
];

let piece, pos;
let dropCounter = 0;
let dropInterval = 500;
let lastTime = 0;
let gameOver = false;

function newPiece(){
 const type = Math.floor(Math.random()*7)+1;
 piece = SHAPES[type].map(r=>r.slice());
 pos = {x:3,y:0};
 if(collide()){
  gameOver = true;
 }
}

function rotate(matrix){
 return matrix[0].map((_,i)=>matrix.map(r=>r[i]).reverse());
}

function collide(){
 for(let y=0;y<piece.length;y++){
  for(let x=0;x<piece[y].length;x++){
   if(piece[y][x]){
    let bx = x + pos.x;
    let by = y + pos.y;
    if(bx<0 || bx>=COLS || by>=ROWS || board[by]?.[bx]){
     return true;
    }
   }
  }
 }
 return false;
}

function merge(){
 piece.forEach((row,y)=>{
  row.forEach((v,x)=>{
   if(v) board[y+pos.y][x+pos.x]=v;
  });
 });
}

function clearLines(){
 outer:for(let y=ROWS-1;y>=0;y--){
  for(let x=0;x<COLS;x++){
   if(!board[y][x]) continue outer;
  }
  board.splice(y,1);
  board.unshift(Array(COLS).fill(0));
  y++;
 }
}

function drawBlock(x,y,color){
 ctx.fillStyle=color;
 ctx.fillRect(x*SIZE,y*SIZE,SIZE,SIZE);
 ctx.strokeStyle="#000";
 ctx.strokeRect(x*SIZE,y*SIZE,SIZE,SIZE);
}

function draw(){
 ctx.clearRect(0,0,300,600);

 board.forEach((row,y)=>{
  row.forEach((v,x)=>{
   if(v) drawBlock(x,y,COLORS[v]);
  });
 });

 piece.forEach((row,y)=>{
  row.forEach((v,x)=>{
   if(v) drawBlock(x+pos.x,y+pos.y,COLORS[v]);
  });
 });

 if(gameOver){
  ctx.fillStyle="rgba(0,0,0,0.7)";
  ctx.fillRect(0,0,300,600);
  ctx.fillStyle="white";
  ctx.font="30px sans-serif";
  ctx.fillText("GAME OVER",35,300);
 }
}

function update(time=0){
 const delta = time - lastTime;
 lastTime = time;
 dropCounter += delta;

 if(dropCounter > dropInterval){
  pos.y++;
  if(collide()){
   pos.y--;
   merge();
   clearLines();
   newPiece();
  }
  dropCounter = 0;
 }

 draw();
 if(!gameOver) requestAnimationFrame(update);
}

document.addEventListener("keydown",e=>{
 if(gameOver) return;

 if(e.key==="ArrowLeft"){
  pos.x--;
  if(collide()) pos.x++;
 }
 if(e.key==="ArrowRight"){
  pos.x++;
  if(collide()) pos.x--;
 }
 if(e.key==="ArrowDown"){
  pos.y++;
  if(collide()) pos.y--;
 }
 if(e.key==="ArrowUp"){
  const rotated = rotate(piece);
  const old = piece;
  piece = rotated;
  if(collide()) piece = old;
 }
 if(e.code==="Space"){
  while(!collide()) pos.y++;
  pos.y--;
 }
});

newPiece();
update();
</script>

</body>
</html>
