<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>ブロック崩し</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
html,body{
 margin:0;
 width:100%;
 height:100%;
 background:#111;
 overflow:hidden;
 font-family:sans-serif;
}
canvas{
 display:block;
 background:#222;
 touch-action:none;
}
#starBtn{
 position:absolute;
 top:10px;
 right:10px;
 width:50px; height:50px;
 background:gold;
 border-radius:50%;
 font-size:24px;
 border:none;
 cursor:pointer;
 z-index:10;
}
</style>
</head>
<body>

<button id="starBtn">⭐︎</button>
<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const starBtn = document.getElementById("starBtn");

// ===== 基本設定 =====
const GRID = 8;
let W,H,SIZE,OFFSET_Y,SLOT_Y;
const SLOT_SCALE = 0.7;

let board, colorBoard, pieces, dragging=null;
let score = 0;
let combo = 0;
let bugMode = false;
let gameOver = false;

// ===== ブロック形 =====
const SHAPES = [
 [[1]],
 [[1,1]],
 [[1],[1]],
 [[1,1,1]],
 [[1],[1],[1]],
 [[1,1],[1,1]],
 [[1,1,1],[0,1,0]]
];

// ===== 色 =====
function randomColor(){ return '#'+Math.floor(Math.random()*16777215).toString(16); }

// ===== 画面サイズ =====
function resize(){
 W = window.innerWidth;
 H = window.innerHeight;
 canvas.width = W;
 canvas.height = H;

 SIZE = Math.floor(W / (GRID + 1));
 OFFSET_Y = SIZE * 1.5;
 SLOT_Y = OFFSET_Y + GRID * SIZE + SIZE*0.6;

 // 下のブロック位置調整
 if(pieces){
   pieces.forEach((p,i)=>{
     p.y = SLOT_Y;
     p.x = W/2 + (i-1)*SIZE*3;
   });
 }
}
window.addEventListener("resize", resize);

// ===== 初期化 =====
function reset(){
 board = Array.from({length:GRID},()=>Array(GRID).fill(0));
 colorBoard = Array.from({length:GRID},()=>Array(GRID).fill("#4caf50"));
 score = 0;
 combo = 0;
 gameOver = false;
 newPieces();
}
reset();
resize();

// ===== 新ブロック =====
function newPieces(){
 pieces=[];
 for(let i=0;i<3;i++){
  const shape = SHAPES[Math.floor(Math.random()*SHAPES.length)];
  const color = randomColor();
  pieces.push({
   shape: shape,
   color: color,
   x: W/2 + (i-1)*SIZE*3,
   y: SLOT_Y
  });
 }
}

// ===== 描画 =====
function drawCell(x,y,s,color){
 ctx.fillStyle=color;
 ctx.fillRect(x,y,s,s);
 ctx.strokeStyle="#333";
 ctx.strokeRect(x,y,s,s);
}

// ===== 判定 =====
function canPlace(px,py,shape){
 for(let y=0;y<shape.length;y++){
  for(let x=0;x<shape[y].length;x++){
   if(shape[y][x]){
    let gx = Math.floor((px+x*SIZE)/SIZE);
    let gy = Math.floor((py+y*SIZE-OFFSET_Y)/SIZE);
    if(gx<0||gx>=GRID||gy<0||gy>=GRID||board[gy][gx]) return false;
   }
  }
 }
 return true;
}

function place(px,py,piece){
 piece.shape.forEach((r,y)=>r.forEach((v,x)=>{
  if(v){
   let gx=Math.floor((px+x*SIZE)/SIZE);
   let gy=Math.floor((py+y*SIZE-OFFSET_Y)/SIZE);
   board[gy][gx]=1;
   colorBoard[gy][gx]=piece.color;
  }
 }));
}

// ===== ライン消去＋コンボ =====
function clearLines(){
 let cleared = 0;

 for(let y=0;y<GRID;y++){
  if(board[y].every(v=>v)){
   board[y].fill(0);
   for(let x=0;x<GRID;x++) colorBoard[y][x]=randomColor();
   cleared++;
  }
 }

 for(let x=0;x<GRID;x++){
  let full=true;
  for(let y=0;y<GRID;y++) if(!board[y][x]) full=false;
  if(full){
   for(let y=0;y<GRID;y++){
     board[y][x]=0;
     colorBoard[y][x]=randomColor();
   }
   cleared++;
  }
 }

 if(cleared > 0){
  combo++;
  let base = cleared * 100;
  let bonus = Math.round(base * (combo>1 ? 1.45 : 1));
  score += bonus;
  if(bugMode){
   // バグモードでブロック増殖
   for(let i=0;i<cleared;i++){
     const r = Math.floor(Math.random()*GRID);
     const c = Math.floor(Math.random()*GRID);
     board[r][c]=1;
     colorBoard[r][c]=randomColor();
   }
  }
 }else{
  combo = 0;
 }
}

// ===== ゴースト位置 =====
function ghostPos(p){
 return {
  x: Math.round(p.x / SIZE) * SIZE,
  y: Math.round((p.y-OFFSET_Y)/SIZE)*SIZE + OFFSET_Y
 };
}

// ===== 描画全体 =====
function draw(){
 ctx.clearRect(0,0,W,H);

 // バグモードカオス
 if(bugMode){
  for(let y=0;y<GRID;y++){
   for(let x=0;x<GRID;x++){
    if(board[y][x]){
     drawCell(x*SIZE + Math.random()*20-10,
              OFFSET_Y+y*SIZE + Math.random()*20-10,
              SIZE,
              '#'+Math.floor(Math.random()*16777215).toString(16));
    }
   }
  }
  pieces.forEach(p=>{
   p.shape.forEach((r,y)=>r.forEach((v,x)=>{
    if(v){
     drawCell(p.x + x*SIZE + Math.random()*40-20,
              p.y + y*SIZE + Math.random()*40-20,
              SIZE, '#'+Math.floor(Math.random()*16777215).toString(16));
    }
   }));
  });
  ctx.fillStyle='white';
  ctx.font='30px sans-serif';
  ctx.fillText("バグモード発動中！",10,50);
  return;
}

// タイトル
 ctx.fillStyle="white";
 ctx.font=`bold ${SIZE*0.7}px sans-serif`;
 ctx.fillText("ブロック崩し", 10, SIZE);

// 点線グリッド
 ctx.setLineDash([5,5]);
 ctx.strokeStyle="#444";
 for(let i=0;i<=GRID;i++){
  ctx.beginPath();
  ctx.moveTo(i*SIZE, OFFSET_Y);
  ctx.lineTo(i*SIZE, OFFSET_Y+GRID*SIZE);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(0, OFFSET_Y+i*SIZE);
  ctx.lineTo(GRID*SIZE, OFFSET_Y+i*SIZE);
  ctx.stroke();
 }
 ctx.setLineDash([]);

// 固定ブロック
 for(let y=0;y<GRID;y++){
  for(let x=0;x<GRID;x++){
   if(board[y][x]){
    drawCell(x*SIZE, OFFSET_Y+y*SIZE, SIZE, colorBoard[y][x]);
   }
  }
 }

// ゴースト
 if(dragging){
  const g = ghostPos(dragging.p);
  if(canPlace(g.x,g.y,dragging.p.shape)){
   ctx.globalAlpha=0.4;
   dragging.p.shape.forEach((r,y)=>r.forEach((v,x)=>{
    if(v) drawCell(g.x+x*SIZE, g.y+y*SIZE, SIZE, dragging.p.color);
   }));
   ctx.globalAlpha=1;
  }
 }

// 手持ちブロック
 pieces.forEach(p=>{
  const s = (p.y>=SLOT_Y)? SIZE*SLOT_SCALE : SIZE;
  p.shape.forEach((r,y)=>r.forEach((v,x)=>{
   if(v) drawCell(p.x+x*s, p.y+y*s, s, p.color);
  }));
 });

// スコア
 ctx.fillStyle="white";
 ctx.font=`${SIZE*0.5}px sans-serif`;
 ctx.fillText("SCORE: "+score, 10, OFFSET_Y+GRID*SIZE+SIZE*0.7);

// コンボ
 if(combo>1){
  ctx.fillText("COMBO x"+combo, 10, OFFSET_Y+GRID*SIZE+SIZE*1.3);
 }

// ゲームオーバー
 if(gameOver){
  ctx.fillStyle="rgba(0,0,0,0.7)";
  ctx.fillRect(0,0,W,H);
  ctx.fillStyle="white";
  ctx.font="40px sans-serif";
  ctx.fillText("GAME OVER",W/6,H/2);
 }
}

// ===== 入力 =====
canvas.addEventListener("pointerdown",e=>{
 if(gameOver) return;
 const r=canvas.getBoundingClientRect();
 const mx=e.clientX-r.left, my=e.clientY-r.top;
 pieces.forEach(p=>{
  const s=(p.y>=SLOT_Y)?SIZE*SLOT_SCALE:SIZE;
  const w=p.shape[0].length*s, h=p.shape.length*s;
  if(mx>p.x&&mx<p.x+w&&my>p.y&&my<p.y+h){
   dragging={p,ox:mx-p.x,oy:my-p.y};
  }
 });
});

canvas.addEventListener("pointermove",e=>{
 if(!dragging) return;
 const r=canvas.getBoundingClientRect();
 dragging.p.x=e.clientX-r.left-dragging.ox;
 dragging.p.y=e.clientY-r.top-dragging.oy;
});

canvas.addEventListener("pointerup",()=>{
 if(gameOver) return;
 if(!dragging) return;
 const p=dragging.p;
 const g=ghostPos(p);

 if(canPlace(g.x,g.y,p.shape)){
  place(g.x,g.y,p);
  pieces=pieces.filter(x=>x!==p);
  clearLines();
  if(pieces.length===0) newPieces();
 }else{
  p.y=SLOT_Y;
 }

 // ゲームオーバー判定
 let canAnyPlace=false;
 for(let i=0;i<pieces.length;i++){
  if(canPlace(pieces[i].x,pieces[i].y,pieces[i].shape)){
   canAnyPlace=true; break;
  }
 }
 if(!canAnyPlace) gameOver=true;

 dragging=null;
});

// ===== ⭐︎ボタン =====
starBtn.addEventListener("click",()=>{
 const code = prompt("ボーナスコードを入力");
 if(code === "810senpai"){
  bugMode = true;
  alert("バグモード発動！めちゃくちゃになる！");
 }
});

// ===== ループ =====
function loop(){
 draw();
 requestAnimationFrame(loop);
}
loop();
</script>

</body>
</html>
