<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Block Blast</title>
<style>
body{
 margin:0;
 background:#111;
 display:flex;
 justify-content:center;
 align-items:center;
 height:100vh;
}
canvas{
 background:#222;
 touch-action:none;
}
</style>
</head>
<body>

<canvas id="game" width="360" height="500"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const GRID = 8;
const SIZE = 40;
const OFFSET_Y = 20;
const SLOT_Y = 380;

let board = Array.from({length:GRID},()=>Array(GRID).fill(0));
let pieces = [];
let dragging = null;

const SHAPES = [
 [[1]],
 [[1,1]],
 [[1],[1]],
 [[1,1,1]],
 [[1],[1],[1]],
 [[1,1],[1,1]],
 [[1,1,1],[0,1,0]]
];

function newPieces(){
 pieces = [];
 for(let i=0;i<3;i++){
  pieces.push({
   shape: SHAPES[Math.floor(Math.random()*SHAPES.length)],
   x: 60 + i*110,
   y: SLOT_Y
  });
 }
}

function drawCell(x,y,color){
 ctx.fillStyle=color;
 ctx.fillRect(x,y,SIZE,SIZE);
 ctx.strokeStyle="#333";
 ctx.strokeRect(x,y,SIZE,SIZE);
}

function draw(){
 ctx.clearRect(0,0,360,500);

 // ボード
 for(let y=0;y<GRID;y++){
  for(let x=0;x<GRID;x++){
   drawCell(x*SIZE, y*SIZE+OFFSET_Y,
    board[y][x] ? "#4caf50" : "#333");
  }
 }

 // ピース
 pieces.forEach(p=>{
  p.shape.forEach((row,y)=>{
   row.forEach((v,x)=>{
    if(v){
     drawCell(p.x+x*SIZE, p.y+y*SIZE, "#fbc02d");
    }
   });
  });
 });

 // ラベル
 ctx.fillStyle="white";
 ctx.font="16px sans-serif";
 ctx.fillText("置いて消そう", 10, 15);
}

function canPlace(px,py,shape){
 for(let y=0;y<shape.length;y++){
  for(let x=0;x<shape[y].length;x++){
   if(shape[y][x]){
    let gx = Math.floor((px+x*SIZE)/SIZE);
    let gy = Math.floor((py+y*SIZE-OFFSET_Y)/SIZE);
    if(gx<0||gx>=GRID||gy<0||gy>=GRID||board[gy][gx]){
     return false;
    }
   }
  }
 }
 return true;
}

function place(px,py,piece){
 piece.shape.forEach((row,y)=>{
  row.forEach((v,x)=>{
   if(v){
    let gx = Math.floor((px+x*SIZE)/SIZE);
    let gy = Math.floor((py+y*SIZE-OFFSET_Y)/SIZE);
    board[gy][gx]=1;
   }
  });
 });
}

function clearLines(){
 let cleared = false;

 for(let y=0;y<GRID;y++){
  if(board[y].every(v=>v)){
   board[y].fill(0);
   cleared = true;
  }
 }

 for(let x=0;x<GRID;x++){
  let full = true;
  for(let y=0;y<GRID;y++){
   if(!board[y][x]) full=false;
  }
  if(full){
   for(let y=0;y<GRID;y++) board[y][x]=0;
   cleared = true;
  }
 }

 return cleared;
}

canvas.addEventListener("pointerdown",e=>{
 const r = canvas.getBoundingClientRect();
 const mx = e.clientX - r.left;
 const my = e.clientY - r.top;

 pieces.forEach(p=>{
  const w = p.shape[0].length * SIZE;
  const h = p.shape.length * SIZE;
  if(mx>p.x && mx<p.x+w && my>p.y && my<p.y+h){
   dragging = {p, ox:mx-p.x, oy:my-p.y};
  }
 });
});

canvas.addEventListener("pointermove",e=>{
 if(!dragging) return;
 const r = canvas.getBoundingClientRect();
 dragging.p.x = e.clientX - r.left - dragging.ox;
 dragging.p.y = e.clientY - r.top - dragging.oy;
});

canvas.addEventListener("pointerup",()=>{
 if(!dragging) return;
 const p = dragging.p;

 if(canPlace(p.x,p.y,p.shape)){
  place(p.x,p.y,p);
  pieces = pieces.filter(x=>x!==p);
  clearLines();
  if(pieces.length===0) newPieces();
 }else{
  p.x = 60 + pieces.indexOf(p)*110;
  p.y = SLOT_Y;
 }
 dragging = null;
});

newPieces();
function loop(){
 draw();
 requestAnimationFrame(loop);
}
loop();
</script>

</body>
</html>
